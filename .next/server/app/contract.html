<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/5ab479793bdd2ea5.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-308266bd15f03aae.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-5ffbe5df5ef9d7b2.js" async=""></script><script src="/_next/static/chunks/main-app-172e3ed2787ae625.js" async=""></script><script src="/_next/static/chunks/972-997644fce10d8ed5.js" async=""></script><script src="/_next/static/chunks/app/layout-a31e498a2a532071.js" async=""></script><title>GenLayer Benchmark</title><meta name="description" content="Polymarket resolution via GenLayer Intelligent Contracts"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><nav style="background:#161b22;border-bottom:1px solid #30363d;padding:1rem 0;margin-bottom:2rem"><div class="container" style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem"><a style="font-size:1.5rem;font-weight:bold;color:#58a6ff;text-decoration:none" href="/">ðŸ”¬ GenLayer Benchmark</a><div style="display:flex;gap:2rem;align-items:center"><a href="/markets">Markets</a><a href="/contract">Contract</a><a href="/results">Results</a></div></div></nav><main class="container" style="padding-bottom:4rem"><h1 style="font-size:2rem;margin-bottom:1rem">Contract Code</h1><p style="color:#8b949e;margin-bottom:2rem">PolymarketResolver Intelligent Contract</p><div class="card" style="margin-bottom:2rem"><h3 style="margin-bottom:1rem">Contract Features</h3><ul style="line-height:1.8;color:#8b949e"><li>ðŸ“¡ <strong>Web Access:</strong> Fetches resolution URLs with error handling</li><li>ðŸ¤– <strong>LLM Resolution:</strong> Uses AI to determine YES/NO from content</li><li>ðŸ”’ <strong>Consensus:</strong> Multiple validators reach agreement</li><li>ðŸ“Š <strong>Diagnostics:</strong> Tracks HTTP status, paywall detection, failure reasons</li><li>âœ… <strong>Validation:</strong> Compares GenLayer result with Polymarket outcome</li></ul></div><div class="card"><pre style="max-height:600px;overflow:auto;margin:0"><code># { &quot;Depends&quot;: &quot;py-genlayer:latest&quot; }
from genlayer import *
import json


@allow_storage
class MarketResult:
    market_id: str
    question: str
    resolution_url: str
    polymarket_result: str
    
    # Resolution outcome
    resolvable: bool
    genlayer_result: str  # YES | NO | UNRESOLVABLE
    correct: bool  # genlayer matches polymarket
    
    # Diagnostics (when not resolvable)
    failure_reason: str  # web_* | content_* | llm_* | empty
    status_code: u256    # HTTP status code (0 if not applicable)
    error_detail: str    # specific error message
    
    # LLM reasoning (when resolvable)
    reasoning: str
    
    timestamp: str

    def __init__(
        self,
        market_id: str,
        question: str,
        resolution_url: str,
        polymarket_result: str,
        resolvable: bool,
        genlayer_result: str,
        correct: bool,
        failure_reason: str,
        status_code: u256,
        error_detail: str,
        reasoning: str,
        timestamp: str
    ):
        self.market_id = market_id
        self.question = question
        self.resolution_url = resolution_url
        self.polymarket_result = polymarket_result
        self.resolvable = resolvable
        self.genlayer_result = genlayer_result
        self.correct = correct
        self.failure_reason = failure_reason
        self.status_code = status_code
        self.error_detail = error_detail
        self.reasoning = reasoning
        self.timestamp = timestamp

    def to_dict(self) -&gt; dict:
        return {
            &quot;market_id&quot;: self.market_id,
            &quot;question&quot;: self.question,
            &quot;resolution_url&quot;: self.resolution_url,
            &quot;polymarket_result&quot;: self.polymarket_result,
            &quot;resolvable&quot;: self.resolvable,
            &quot;genlayer_result&quot;: self.genlayer_result,
            &quot;correct&quot;: self.correct,
            &quot;failure_reason&quot;: self.failure_reason,
            &quot;status_code&quot;: int(self.status_code),
            &quot;error_detail&quot;: self.error_detail,
            &quot;reasoning&quot;: self.reasoning,
            &quot;timestamp&quot;: self.timestamp
        }


class PolymarketResolver(gl.Contract):
    results: DynArray[MarketResult]

    def __init__(self):
        pass

    def _normalize_url(self, url: str) -&gt; str:
        &quot;&quot;&quot;Ensure URL has proper protocol.&quot;&quot;&quot;
        url = url.strip()
        if not url.startswith(&quot;http://&quot;) and not url.startswith(&quot;https://&quot;):
            url = &quot;https://&quot; + url
        return url

    def _parse_status_code(self, error_str: str) -&gt; int:
        &quot;&quot;&quot;Extract HTTP status code from error message.&quot;&quot;&quot;
        error_lower = error_str.lower()
        if &quot;403&quot; in error_str:
            return 403
        elif &quot;404&quot; in error_str:
            return 404
        elif &quot;500&quot; in error_str:
            return 500
        elif &quot;502&quot; in error_str:
            return 502
        elif &quot;503&quot; in error_str:
            return 503
        elif &quot;429&quot; in error_str:
            return 429
        elif &quot;401&quot; in error_str:
            return 401
        return 0

    @gl.public.write
    def resolve_market(
        self,
        market_id: str,
        question: str,
        resolution_url: str,
        polymarket_result: str
    ) -&gt; dict:
        &quot;&quot;&quot;
        Resolve a single Polymarket market.
        
        Returns:
            - resolvable: bool
            - if not resolvable: failure_reason + status_code + error_detail
            - if resolvable: genlayer_result + correct + reasoning
        &quot;&quot;&quot;
        timestamp = gl.message_raw[&quot;datetime&quot;]
        normalized_url = self._normalize_url(resolution_url)
        
        def resolve_fn() -&gt; str:
            # === PHASE 1: WEB FETCH ===
            status_code = 0
            try:
                content = gl.nondet.web.render(normalized_url, mode=&#x27;text&#x27;)
            except Exception as e:
                error_str = str(e)
                error_lower = error_str.lower()
                status_code = 0
                
                # Parse status code from error
                for code in [&quot;403&quot;, &quot;404&quot;, &quot;500&quot;, &quot;502&quot;, &quot;503&quot;, &quot;429&quot;, &quot;401&quot;]:
                    if code in error_str:
                        status_code = int(code)
                        break
                
                # Categorize web errors
                if &quot;403&quot; in error_str or &quot;forbidden&quot; in error_lower:
                    failure_reason = &quot;web_forbidden&quot;
                    error_detail = &quot;403 Forbidden - access denied&quot;
                elif &quot;404&quot; in error_str or &quot;not found&quot; in error_lower:
                    failure_reason = &quot;web_not_found&quot;
                    error_detail = &quot;404 Not Found - page does not exist&quot;
                elif &quot;429&quot; in error_str or &quot;rate limit&quot; in error_lower:
                    failure_reason = &quot;web_rate_limited&quot;
                    error_detail = &quot;429 Too Many Requests - rate limited&quot;
                elif &quot;timeout&quot; in error_lower or &quot;timed out&quot; in error_lower:
                    failure_reason = &quot;web_timeout&quot;
                    error_detail = &quot;Request timed out&quot;
                elif &quot;ssl&quot; in error_lower or &quot;certificate&quot; in error_lower:
                    failure_reason = &quot;web_ssl_error&quot;
                    error_detail = &quot;SSL/certificate error&quot;
                elif &quot;dns&quot; in error_lower or &quot;resolve&quot; in error_lower or &quot;getaddrinfo&quot; in error_lower:
                    failure_reason = &quot;web_dns_error&quot;
                    error_detail = &quot;DNS resolution failed - domain may not exist&quot;
                elif &quot;connection&quot; in error_lower or &quot;refused&quot; in error_lower:
                    failure_reason = &quot;web_connection_error&quot;
                    error_detail = &quot;Connection refused or failed&quot;
                elif &quot;500&quot; in error_str or &quot;502&quot; in error_str or &quot;503&quot; in error_str:
                    failure_reason = &quot;web_server_error&quot;
                    error_detail = f&quot;Server error ({status_code})&quot;
                else:
                    failure_reason = &quot;web_unknown_error&quot;
                    error_detail = error_str[:200]
                
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: failure_reason,
                    &quot;status_code&quot;: status_code,
                    &quot;error_detail&quot;: error_detail,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            # === PHASE 2: CONTENT VALIDATION ===
            content_stripped = content.strip() if content else &quot;&quot;
            
            if len(content_stripped) == 0:
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;content_empty&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;Page returned empty content&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            if len(content_stripped) &lt; 100:
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;content_insufficient&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: f&quot;Page content too short ({len(content_stripped)} chars)&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            # Check for anti-bot / access denied patterns in content
            content_lower = content_stripped.lower()
            if any(pattern in content_lower for pattern in [
                &quot;access denied&quot;, 
                &quot;please verify you are human&quot;,
                &quot;enable javascript&quot;,
                &quot;checking your browser&quot;,
                &quot;captcha&quot;,
                &quot;cloudflare&quot;
            ]):
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;content_anti_bot&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;Anti-bot protection detected in page content&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            if any(pattern in content_lower for pattern in [
                &quot;subscribe to continue&quot;,
                &quot;subscription required&quot;,
                &quot;paywall&quot;,
                &quot;premium content&quot;,
                &quot;sign in to read&quot;
            ]):
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;content_paywall&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;Paywall detected - content not accessible&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            # === PHASE 3: LLM RESOLUTION ===
            try:
                prompt = f&quot;&quot;&quot;You are resolving a prediction market.

Question: {question}

Webpage content (from {normalized_url}):
{content_stripped[:8000]}

Based ONLY on the webpage content above, determine if this question resolved YES or NO.

Return JSON:
{{
  &quot;answer&quot;: &quot;YES&quot; or &quot;NO&quot; or &quot;UNRESOLVABLE&quot;,
  &quot;reasoning&quot;: &quot;Brief explanation of why, citing specific evidence from the page&quot;
}}

If the content does not contain enough information to definitively answer the question, return &quot;UNRESOLVABLE&quot;.&quot;&quot;&quot;
                
                llm_response = gl.nondet.exec_prompt(prompt, response_format=&#x27;json&#x27;)
            except Exception as e:
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;llm_error&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: f&quot;LLM execution failed: {str(e)[:150]}&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            # === PHASE 4: PARSE LLM RESPONSE ===
            if not isinstance(llm_response, dict):
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;llm_invalid_response&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;LLM did not return valid JSON object&quot;,
                    &quot;reasoning&quot;: &quot;&quot;
                })
            
            answer = llm_response.get(&quot;answer&quot;, &quot;&quot;)
            reasoning = llm_response.get(&quot;reasoning&quot;, &quot;&quot;)
            
            if not answer:
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;llm_no_answer&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;LLM response missing &#x27;answer&#x27; field&quot;,
                    &quot;reasoning&quot;: reasoning
                })
            
            # Normalize answer
            answer = answer.upper().strip()
            if &quot;YES&quot; in answer:
                answer = &quot;YES&quot;
            elif &quot;NO&quot; in answer:
                answer = &quot;NO&quot;
            else:
                # LLM explicitly couldn&#x27;t resolve
                return json.dumps({
                    &quot;resolvable&quot;: False,
                    &quot;genlayer_result&quot;: &quot;UNRESOLVABLE&quot;,
                    &quot;failure_reason&quot;: &quot;llm_unresolvable&quot;,
                    &quot;status_code&quot;: 200,
                    &quot;error_detail&quot;: &quot;LLM could not determine YES/NO from content&quot;,
                    &quot;reasoning&quot;: reasoning
                })
            
            # === SUCCESS ===
            return json.dumps({
                &quot;resolvable&quot;: True,
                &quot;genlayer_result&quot;: answer,
                &quot;failure_reason&quot;: &quot;&quot;,
                &quot;status_code&quot;: 200,
                &quot;error_detail&quot;: &quot;&quot;,
                &quot;reasoning&quot;: reasoning
            })
        
        # === CONSENSUS ===
        result_json_str = gl.eq_principle.prompt_comparative(
            resolve_fn,
            principle=&quot;Results are equivalent if they have the same answer (YES/NO/UNRESOLVABLE) and the reasoning supports that answer&quot;
        )
        
        # Parse result - handle both dict and string returns
        if isinstance(result_json_str, dict):
            result_data = result_json_str
        else:
            result_data = json.loads(result_json_str)
        
        # Determine correctness
        genlayer_result = result_data.get(&quot;genlayer_result&quot;, &quot;UNRESOLVABLE&quot;)
        resolvable = result_data.get(&quot;resolvable&quot;, False)
        
        # Normalize BOTH for comparison (uppercase, strip whitespace)
        poly_normalized = polymarket_result.upper().strip()
        genlayer_normalized = genlayer_result.upper().strip()
        
        correct = False
        if resolvable and genlayer_normalized in [&quot;YES&quot;, &quot;NO&quot;]:
            correct = (genlayer_normalized == poly_normalized)
        
        market_result = MarketResult(
            market_id=market_id,
            question=question,
            resolution_url=normalized_url,
            polymarket_result=polymarket_result,
            resolvable=resolvable,
            genlayer_result=genlayer_result,
            correct=correct,
            failure_reason=result_data.get(&quot;failure_reason&quot;, &quot;&quot;),
            status_code=u256(result_data.get(&quot;status_code&quot;, 0)),
            error_detail=result_data.get(&quot;error_detail&quot;, &quot;&quot;),
            reasoning=result_data.get(&quot;reasoning&quot;, &quot;&quot;),
            timestamp=timestamp
        )
        
        self.results.append(market_result)
        return market_result.to_dict()

    @gl.public.view
    def get_results(self) -&gt; str:
        &quot;&quot;&quot;Get all resolved markets as JSON string.&quot;&quot;&quot;
        return json.dumps([r.to_dict() for r in self.results])

    @gl.public.view
    def get_result(self, market_id: str) -&gt; dict:
        &quot;&quot;&quot;Get result for a specific market.&quot;&quot;&quot;
        for r in self.results:
            if r.market_id == market_id:
                return r.to_dict()
        return {}

    @gl.public.view
    def get_result_count(self) -&gt; int:
        &quot;&quot;&quot;Get total number of resolved markets.&quot;&quot;&quot;
        return len(self.results)
</code></pre></div></main><footer style="text-align:center;padding:2rem 0;color:#8b949e;font-size:0.9rem;border-top:1px solid #30363d;margin-top:4rem"><div class="container"><div>Contract: <code>0x1414F437fd85Ed7f713756c28b2f03F73A3Dc905</code></div><div style="margin-top:0.5rem">GenLayer Studionet</div></div></footer><script src="/_next/static/chunks/webpack-308266bd15f03aae.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/5ab479793bdd2ea5.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n6:I[6423,[],\"\"]\n7:I[2972,[\"972\",\"static/chunks/972-997644fce10d8ed5.js\",\"185\",\"static/chunks/app/layout-a31e498a2a532071.js\"],\"\"]\n9:I[1060,[],\"\"]\n4:T371a,"])</script><script>self.__next_f.push([1,"# { \"Depends\": \"py-genlayer:latest\" }\nfrom genlayer import *\nimport json\n\n\n@allow_storage\nclass MarketResult:\n    market_id: str\n    question: str\n    resolution_url: str\n    polymarket_result: str\n    \n    # Resolution outcome\n    resolvable: bool\n    genlayer_result: str  # YES | NO | UNRESOLVABLE\n    correct: bool  # genlayer matches polymarket\n    \n    # Diagnostics (when not resolvable)\n    failure_reason: str  # web_* | content_* | llm_* | empty\n    status_code: u256    # HTTP status code (0 if not applicable)\n    error_detail: str    # specific error message\n    \n    # LLM reasoning (when resolvable)\n    reasoning: str\n    \n    timestamp: str\n\n    def __init__(\n        self,\n        market_id: str,\n        question: str,\n        resolution_url: str,\n        polymarket_result: str,\n        resolvable: bool,\n        genlayer_result: str,\n        correct: bool,\n        failure_reason: str,\n        status_code: u256,\n        error_detail: str,\n        reasoning: str,\n        timestamp: str\n    ):\n        self.market_id = market_id\n        self.question = question\n        self.resolution_url = resolution_url\n        self.polymarket_result = polymarket_result\n        self.resolvable = resolvable\n        self.genlayer_result = genlayer_result\n        self.correct = correct\n        self.failure_reason = failure_reason\n        self.status_code = status_code\n        self.error_detail = error_detail\n        self.reasoning = reasoning\n        self.timestamp = timestamp\n\n    def to_dict(self) -\u003e dict:\n        return {\n            \"market_id\": self.market_id,\n            \"question\": self.question,\n            \"resolution_url\": self.resolution_url,\n            \"polymarket_result\": self.polymarket_result,\n            \"resolvable\": self.resolvable,\n            \"genlayer_result\": self.genlayer_result,\n            \"correct\": self.correct,\n            \"failure_reason\": self.failure_reason,\n            \"status_code\": int(self.status_code),\n            \"error_detail\": self.error_detail,\n            \"reasoning\": self.reasoning,\n            \"timestamp\": self.timestamp\n        }\n\n\nclass PolymarketResolver(gl.Contract):\n    results: DynArray[MarketResult]\n\n    def __init__(self):\n        pass\n\n    def _normalize_url(self, url: str) -\u003e str:\n        \"\"\"Ensure URL has proper protocol.\"\"\"\n        url = url.strip()\n        if not url.startswith(\"http://\") and not url.startswith(\"https://\"):\n            url = \"https://\" + url\n        return url\n\n    def _parse_status_code(self, error_str: str) -\u003e int:\n        \"\"\"Extract HTTP status code from error message.\"\"\"\n        error_lower = error_str.lower()\n        if \"403\" in error_str:\n            return 403\n        elif \"404\" in error_str:\n            return 404\n        elif \"500\" in error_str:\n            return 500\n        elif \"502\" in error_str:\n            return 502\n        elif \"503\" in error_str:\n            return 503\n        elif \"429\" in error_str:\n            return 429\n        elif \"401\" in error_str:\n            return 401\n        return 0\n\n    @gl.public.write\n    def resolve_market(\n        self,\n        market_id: str,\n        question: str,\n        resolution_url: str,\n        polymarket_result: str\n    ) -\u003e dict:\n        \"\"\"\n        Resolve a single Polymarket market.\n        \n        Returns:\n            - resolvable: bool\n            - if not resolvable: failure_reason + status_code + error_detail\n            - if resolvable: genlayer_result + correct + reasoning\n        \"\"\"\n        timestamp = gl.message_raw[\"datetime\"]\n        normalized_url = self._normalize_url(resolution_url)\n        \n        def resolve_fn() -\u003e str:\n            # === PHASE 1: WEB FETCH ===\n            status_code = 0\n            try:\n                content = gl.nondet.web.render(normalized_url, mode='text')\n            except Exception as e:\n                error_str = str(e)\n                error_lower = error_str.lower()\n                status_code = 0\n                \n                # Parse status code from error\n                for code in [\"403\", \"404\", \"500\", \"502\", \"503\", \"429\", \"401\"]:\n                    if code in error_str:\n                        status_code = int(code)\n                        break\n                \n                # Categorize web errors\n                if \"403\" in error_str or \"forbidden\" in error_lower:\n                    failure_reason = \"web_forbidden\"\n                    error_detail = \"403 Forbidden - access denied\"\n                elif \"404\" in error_str or \"not found\" in error_lower:\n                    failure_reason = \"web_not_found\"\n                    error_detail = \"404 Not Found - page does not exist\"\n                elif \"429\" in error_str or \"rate limit\" in error_lower:\n                    failure_reason = \"web_rate_limited\"\n                    error_detail = \"429 Too Many Requests - rate limited\"\n                elif \"timeout\" in error_lower or \"timed out\" in error_lower:\n                    failure_reason = \"web_timeout\"\n                    error_detail = \"Request timed out\"\n                elif \"ssl\" in error_lower or \"certificate\" in error_lower:\n                    failure_reason = \"web_ssl_error\"\n                    error_detail = \"SSL/certificate error\"\n                elif \"dns\" in error_lower or \"resolve\" in error_lower or \"getaddrinfo\" in error_lower:\n                    failure_reason = \"web_dns_error\"\n                    error_detail = \"DNS resolution failed - domain may not exist\"\n                elif \"connection\" in error_lower or \"refused\" in error_lower:\n                    failure_reason = \"web_connection_error\"\n                    error_detail = \"Connection refused or failed\"\n                elif \"500\" in error_str or \"502\" in error_str or \"503\" in error_str:\n                    failure_reason = \"web_server_error\"\n                    error_detail = f\"Server error ({status_code})\"\n                else:\n                    failure_reason = \"web_unknown_error\"\n                    error_detail = error_str[:200]\n                \n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": failure_reason,\n                    \"status_code\": status_code,\n                    \"error_detail\": error_detail,\n                    \"reasoning\": \"\"\n                })\n            \n            # === PHASE 2: CONTENT VALIDATION ===\n            content_stripped = content.strip() if content else \"\"\n            \n            if len(content_stripped) == 0:\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"content_empty\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"Page returned empty content\",\n                    \"reasoning\": \"\"\n                })\n            \n            if len(content_stripped) \u003c 100:\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"content_insufficient\",\n                    \"status_code\": 200,\n                    \"error_detail\": f\"Page content too short ({len(content_stripped)} chars)\",\n                    \"reasoning\": \"\"\n                })\n            \n            # Check for anti-bot / access denied patterns in content\n            content_lower = content_stripped.lower()\n            if any(pattern in content_lower for pattern in [\n                \"access denied\", \n                \"please verify you are human\",\n                \"enable javascript\",\n                \"checking your browser\",\n                \"captcha\",\n                \"cloudflare\"\n            ]):\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"content_anti_bot\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"Anti-bot protection detected in page content\",\n                    \"reasoning\": \"\"\n                })\n            \n            if any(pattern in content_lower for pattern in [\n                \"subscribe to continue\",\n                \"subscription required\",\n                \"paywall\",\n                \"premium content\",\n                \"sign in to read\"\n            ]):\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"content_paywall\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"Paywall detected - content not accessible\",\n                    \"reasoning\": \"\"\n                })\n            \n            # === PHASE 3: LLM RESOLUTION ===\n            try:\n                prompt = f\"\"\"You are resolving a prediction market.\n\nQuestion: {question}\n\nWebpage content (from {normalized_url}):\n{content_stripped[:8000]}\n\nBased ONLY on the webpage content above, determine if this question resolved YES or NO.\n\nReturn JSON:\n{{\n  \"answer\": \"YES\" or \"NO\" or \"UNRESOLVABLE\",\n  \"reasoning\": \"Brief explanation of why, citing specific evidence from the page\"\n}}\n\nIf the content does not contain enough information to definitively answer the question, return \"UNRESOLVABLE\".\"\"\"\n                \n                llm_response = gl.nondet.exec_prompt(prompt, response_format='json')\n            except Exception as e:\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"llm_error\",\n                    \"status_code\": 200,\n                    \"error_detail\": f\"LLM execution failed: {str(e)[:150]}\",\n                    \"reasoning\": \"\"\n                })\n            \n            # === PHASE 4: PARSE LLM RESPONSE ===\n            if not isinstance(llm_response, dict):\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"llm_invalid_response\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"LLM did not return valid JSON object\",\n                    \"reasoning\": \"\"\n                })\n            \n            answer = llm_response.get(\"answer\", \"\")\n            reasoning = llm_response.get(\"reasoning\", \"\")\n            \n            if not answer:\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"llm_no_answer\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"LLM response missing 'answer' field\",\n                    \"reasoning\": reasoning\n                })\n            \n            # Normalize answer\n            answer = answer.upper().strip()\n            if \"YES\" in answer:\n                answer = \"YES\"\n            elif \"NO\" in answer:\n                answer = \"NO\"\n            else:\n                # LLM explicitly couldn't resolve\n                return json.dumps({\n                    \"resolvable\": False,\n                    \"genlayer_result\": \"UNRESOLVABLE\",\n                    \"failure_reason\": \"llm_unresolvable\",\n                    \"status_code\": 200,\n                    \"error_detail\": \"LLM could not determine YES/NO from content\",\n                    \"reasoning\": reasoning\n                })\n            \n            # === SUCCESS ===\n            return json.dumps({\n                \"resolvable\": True,\n                \"genlayer_result\": answer,\n                \"failure_reason\": \"\",\n                \"status_code\": 200,\n                \"error_detail\": \"\",\n                \"reasoning\": reasoning\n            })\n        \n        # === CONSENSUS ===\n        result_json_str = gl.eq_principle.prompt_comparative(\n            resolve_fn,\n            principle=\"Results are equivalent if they have the same answer (YES/NO/UNRESOLVABLE) and the reasoning supports that answer\"\n        )\n        \n        # Parse result - handle both dict and string returns\n        if isinstance(result_json_str, dict):\n            result_data = result_json_str\n        else:\n            result_data = json.loads(result_json_str)\n        \n        # Determine correctness\n        genlayer_result = result_data.get(\"genlayer_result\", \"UNRESOLVABLE\")\n        resolvable = result_data.get(\"resolvable\", False)\n        \n        # Normalize BOTH for comparison (uppercase, strip whitespace)\n        poly_normalized = polymarket_result.upper().strip()\n        genlayer_normalized = genlayer_result.upper().strip()\n        \n        correct = False\n        if resolvable and genlayer_normalized in [\"YES\", \"NO\"]:\n            correct = (genlayer_normalized == poly_normalized)\n        \n        market_result = MarketResult(\n            market_id=market_id,\n            question=question,\n            resolution_url=normalized_url,\n            polymarket_result=polymarket_result,\n            resolvable=resolvable,\n            genlayer_result=genlayer_result,\n            correct=correct,\n            failure_reason=result_data.get(\"failure_reason\", \"\"),\n            status_code=u256(result_data.get(\"status_code\", 0)),\n            error_detail=result_data.get(\"error_detail\", \"\"),\n            reasoning=result_data.get(\"reasoning\", \"\"),\n            timestamp=timestamp\n        )\n        \n        self.results.append(market_result)\n        return market_result.to_dict()\n\n    @gl.public.view\n    def get_results(self) -\u003e str:\n        \"\"\"Get all resolved markets as JSON string.\"\"\"\n        return json.dumps([r.to_dict() for r in self.results])\n\n    @gl.public.view\n    def get_result(self, market_id: str) -\u003e dict:\n        \"\"\"Get result for a specific market.\"\"\"\n        for r in self.results:\n            if r.market_id == market_id:\n                return r.to_dict()\n        return {}\n\n    @gl.public.view\n    def get_result_count(self) -\u003e int:\n        \"\"\"Get total number of resolved markets.\"\"\"\n        return len(self.results)\n"])</script><script>self.__next_f.push([1,"a:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"NHawL7C4WID5JN8IZ2b52\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"contract\"],\"initialTree\":[\"\",{\"children\":[\"contract\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"contract\",{\"children\":[\"__PAGE__\",{},[[\"$L3\",[[\"$\",\"h1\",null,{\"style\":{\"fontSize\":\"2rem\",\"marginBottom\":\"1rem\"},\"children\":\"Contract Code\"}],[\"$\",\"p\",null,{\"style\":{\"color\":\"#8b949e\",\"marginBottom\":\"2rem\"},\"children\":\"PolymarketResolver Intelligent Contract\"}],[\"$\",\"div\",null,{\"className\":\"card\",\"style\":{\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"h3\",null,{\"style\":{\"marginBottom\":\"1rem\"},\"children\":\"Contract Features\"}],[\"$\",\"ul\",null,{\"style\":{\"lineHeight\":\"1.8\",\"color\":\"#8b949e\"},\"children\":[[\"$\",\"li\",null,{\"children\":[\"ðŸ“¡ \",[\"$\",\"strong\",null,{\"children\":\"Web Access:\"}],\" Fetches resolution URLs with error handling\"]}],[\"$\",\"li\",null,{\"children\":[\"ðŸ¤– \",[\"$\",\"strong\",null,{\"children\":\"LLM Resolution:\"}],\" Uses AI to determine YES/NO from content\"]}],[\"$\",\"li\",null,{\"children\":[\"ðŸ”’ \",[\"$\",\"strong\",null,{\"children\":\"Consensus:\"}],\" Multiple validators reach agreement\"]}],[\"$\",\"li\",null,{\"children\":[\"ðŸ“Š \",[\"$\",\"strong\",null,{\"children\":\"Diagnostics:\"}],\" Tracks HTTP status, paywall detection, failure reasons\"]}],[\"$\",\"li\",null,{\"children\":[\"âœ… \",[\"$\",\"strong\",null,{\"children\":\"Validation:\"}],\" Compares GenLayer result with Polymarket outcome\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card\",\"children\":[\"$\",\"pre\",null,{\"style\":{\"maxHeight\":\"600px\",\"overflow\":\"auto\",\"margin\":0},\"children\":[\"$\",\"code\",null,{\"children\":\"$4\"}]}]}]],null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"contract\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5ab479793bdd2ea5.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"nav\",null,{\"style\":{\"background\":\"#161b22\",\"borderBottom\":\"1px solid #30363d\",\"padding\":\"1rem 0\",\"marginBottom\":\"2rem\"},\"children\":[\"$\",\"div\",null,{\"className\":\"container\",\"style\":{\"display\":\"flex\",\"justifyContent\":\"space-between\",\"alignItems\":\"center\",\"flexWrap\":\"wrap\",\"gap\":\"1rem\"},\"children\":[[\"$\",\"$L7\",null,{\"href\":\"/\",\"style\":{\"fontSize\":\"1.5rem\",\"fontWeight\":\"bold\",\"color\":\"#58a6ff\",\"textDecoration\":\"none\"},\"children\":\"ðŸ”¬ GenLayer Benchmark\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"flex\",\"gap\":\"2rem\",\"alignItems\":\"center\"},\"children\":[[\"$\",\"$L7\",null,{\"href\":\"/markets\",\"children\":\"Markets\"}],[\"$\",\"$L7\",null,{\"href\":\"/contract\",\"children\":\"Contract\"}],[\"$\",\"$L7\",null,{\"href\":\"/results\",\"children\":\"Results\"}]]}]]}]}],[\"$\",\"main\",null,{\"className\":\"container\",\"style\":{\"paddingBottom\":\"4rem\"},\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L6\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}],[\"$\",\"footer\",null,{\"style\":{\"textAlign\":\"center\",\"padding\":\"2rem 0\",\"color\":\"#8b949e\",\"fontSize\":\"0.9rem\",\"borderTop\":\"1px solid #30363d\",\"marginTop\":\"4rem\"},\"children\":[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"Contract: \",[\"$\",\"code\",null,{\"children\":\"0x1414F437fd85Ed7f713756c28b2f03F73A3Dc905\"}]]}],[\"$\",\"div\",null,{\"style\":{\"marginTop\":\"0.5rem\"},\"children\":\"GenLayer Studionet\"}]]}]}]]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L8\"],\"globalErrorComponent\":\"$9\",\"missingSlots\":\"$Wa\"}]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"GenLayer Benchmark\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Polymarket resolution via GenLayer Intelligent Contracts\"}]]\n3:null\n"])</script></body></html>